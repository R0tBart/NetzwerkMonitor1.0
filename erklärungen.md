## Verwendete Module und Technologien

### Backend (Server)

*   **Node.js**: Als serverseitige JavaScript-Laufzeitumgebung bildet Node.js das Rückgrat des Backends. Es ermöglicht die Ausführung von JavaScript-Code außerhalb des Browsers und wird für die gesamte serverseitige Logik eingesetzt. Dies umfasst die Verarbeitung eingehender HTTP-Anfragen, die Interaktion mit der Datenbank, die Implementierung der Geschäftslogik und die Bereitstellung von Daten an das Frontend. Die asynchrone, ereignisgesteuerte Architektur von Node.js ist ideal für I/O-intensive Anwendungen wie Netzwerküberwachungssysteme.
*   **Express.js**: Ein minimalistisches und flexibles Webanwendungsframework für Node.js. Express.js wird verwendet, um die RESTful-APIs des Servers zu definieren und zu verwalten. Es bietet robuste Routing-Funktionen, Middleware-Unterstützung für Aufgaben wie Authentifizierung, Logging und Fehlerbehandlung sowie eine einfache Schnittstelle zur Handhabung von HTTP-Anfragen und -Antworten. Dies ermöglicht eine strukturierte und effiziente Entwicklung der API-Schicht.
*   **Drizzle ORM**: Ein modernes, typsicheres TypeScript ORM (Object-Relational Mapper) speziell für relationale Datenbanken. Drizzle ORM abstrahiert die direkte SQL-Interaktion und ermöglicht es Entwicklern, Datenbankoperationen (CRUD-Operationen, Schema-Definitionen, Migrationen) mithilfe von TypeScript-Code durchzuführen. Dies führt zu einer erheblichen Verbesserung der Typsicherheit, reduziert das Risiko von Laufzeitfehlern durch SQL-Injektionen und beschleunigt die Entwicklung durch automatische Schema-Generierung und -Validierung. Es integriert sich nahtlos mit der PostgreSQL-Datenbank.
*   **PostgreSQL**: Eine leistungsstarke, objektrelationale Open-Source-Datenbank. PostgreSQL dient als primärer Datenspeicher für alle persistenten Anwendungsdaten. Dazu gehören detaillierte Netzwerkgerätedaten, historische Bandbreitenmetriken, Protokolle von Sicherheitsereignissen, Benutzerkonten und verschlüsselte Passwort-Tresore. PostgreSQL bietet ACID-Konformität, hohe Zuverlässigkeit, Datenintegrität, komplexe Abfragemöglichkeiten und Skalierbarkeit, was es zu einer robusten Wahl für ein Netzwerküberwachungssystem macht.
*   **`cross-env`**: Ein Hilfsprogramm, das die plattformübergreifende Einstellung von Umgebungsvariablen in Skripten standardisiert. Es ist entscheidend, um sicherzustellen, dass Umgebungsvariablen wie `DATABASE_URL` oder API-Schlüssel konsistent über verschiedene Betriebssysteme (Windows, macOS, Linux) hinweg gesetzt und vom Node.js-Server korrekt gelesen werden können. Dies vereinfacht die Entwicklung und Bereitstellung in heterogenen Umgebungen.
*   **`tsx`**: Ein Kommandozeilen-Tool, das die direkte Ausführung von TypeScript-Dateien ohne vorherige Kompilierung in JavaScript ermöglicht. Dies optimiert den Entwicklungsworkflow erheblich, da Änderungen am TypeScript-Code sofort getestet werden können, ohne einen separaten Build-Schritt ausführen zu müssen. Es verbessert die Entwicklererfahrung durch schnellere Iterationszyklen und eine nahtlose Integration von TypeScript im Entwicklungsprozess.

### Frontend (Client)

*   **React**: Eine deklarative JavaScript-Bibliothek zur Erstellung von Benutzeroberflächen. React wird verwendet, um die gesamte interaktive und dynamische Benutzeroberfläche der Webanwendung zu entwickeln. Durch sein komponentenbasiertes Modell und das virtuelle DOM ermöglicht React eine effiziente und performante Aktualisierung der Benutzeroberfläche, was zu einer reaktionsschnellen und flüssigen Benutzererfahrung führt. Es ist die Grundlage für alle visuellen Elemente und Interaktionen im NetzwerkMonitor.
*   **Vite**: Ein schneller und schlanker Build-Tool, der für die Entwicklung des Frontend verwendet wird. Vite zeichnet sich durch seine "No-Bundler"-Entwicklungserfahrung aus, die auf nativen ES-Modulen basiert. Dies führt zu extrem schnellen Serverstarts und einer Hot Module Replacement (HMR), die nahezu sofortige Aktualisierungen im Browser ermöglicht. Vite optimiert auch den Produktions-Build-Prozess, was zu einer schnellen Ladezeit der Anwendung führt.
*   **TypeScript**: Eine typisierte Obermenge von JavaScript, die statische Typdefinitionen hinzufügt. TypeScript wird im gesamten Frontend eingesetzt, um die Codequalität zu verbessern, potenzielle Fehler während der Entwicklung zu erkennen und die Wartbarkeit großer Codebasen zu erleichtern. Es erzwingt eine strikte Typisierung, was zu robusterem Code führt und die Zusammenarbeit zwischen Frontend- und Backend-Entwicklern durch gemeinsame Typdefinitionen (z.B. in `shared/schema.ts`) erleichtert.
*   **Tailwind CSS**: Ein Utility-First-CSS-Framework, das eine Vielzahl von vordefinierten CSS-Klassen bereitstellt, um schnell und konsistent Benutzeroberflächen zu gestalten. Anstatt vordefinierte Komponenten zu verwenden, ermöglicht Tailwind das direkte Anwenden von Styling-Regeln im HTML-Markup. Dies führt zu hochgradig anpassbaren Designs, reduziert die Notwendigkeit, benutzerdefiniertes CSS zu schreiben, und fördert eine konsistente Designsprache im gesamten Projekt.
*   **Shadcn/ui**: Eine Sammlung von wiederverwendbaren UI-Komponenten, die auf Tailwind CSS und Radix UI basieren. Im Gegensatz zu herkömmlichen UI-Bibliotheken werden Shadcn/ui-Komponenten nicht als npm-Paket installiert, sondern als Code-Snippets direkt in das Projekt kopiert. Dies bietet maximale Flexibilität und Anpassbarkeit, da Entwickler den Code der Komponenten direkt bearbeiten können. Sie bieten eine solide, barrierefreie und ästhetisch ansprechende Basis für konsistente UI-Elemente.
*   **`@tanstack/react-query`**: Eine leistungsstarke Bibliothek zum Abrufen, Zwischenspeichern, Synchronisieren und Aktualisieren von Serverzuständen in React-Anwendungen. Sie wird intensiv genutzt, um API-Anfragen effizient zu verwalten, Ladezustände zu handhaben, Fehler zu behandeln und Daten im Cache zu speichern. Dies reduziert die Anzahl der Netzwerkanfragen, verbessert die Anwendungsleistung und sorgt für eine reibungslose Benutzererfahrung, insbesondere bei der Anzeige von Echtzeitdaten wie Bandbreitennutzung.
*   **Chart.js**: Eine Open-Source-JavaScript-Bibliothek, die eine breite Palette von Diagrammtypen für die Datenvisualisierung bietet. Chart.js wird verwendet, um die gesammelten Netzwerkdaten – wie Bandbreitennutzung, Systemmetriken und den Status von Geräten – in interaktiven und visuell ansprechenden Diagrammen darzustellen. Dies ermöglicht Benutzern, Trends und Muster in den Daten schnell zu erkennen.
*   **`zod`**: Eine TypeScript-first-Schema-Deklarations- und Validierungsbibliothek. `zod` wird für die Validierung von Daten verwendet, die von Formularen oder APIs empfangen werden. Es ermöglicht die Definition von Schemata für Datenstrukturen, die dann zur Laufzeit validiert werden können. Dies stellt sicher, dass die Daten den erwarteten Typen und Strukturen entsprechen, erhöht die Robustheit der Anwendung und verhindert häufige Datenfehler.
*   **`react-hook-form`**: Eine Bibliothek zur einfacheren Formularverwaltung in React. Sie vereinfacht die Erstellung und Validierung von Formularen erheblich, indem sie Hooks bereitstellt, die die Komplexität der Formularzustandsverwaltung reduzieren. `react-hook-form` ist performant, da es unnötige Re-Renderings vermeidet, und integriert sich gut mit Validierungsbibliotheken wie `zod`, um eine robuste Formularhandhabung zu gewährleisten.
*   **`jspdf` & `jspdf-autotable`**: Bibliotheken, die den Export von Dashboard-Daten als PDF-Dokumente ermöglichen. `jspdf` ist die Kernbibliothek für die clientseitige PDF-Generierung, während `jspdf-autotable` die Erstellung von strukturierten Tabellen innerhalb der generierten PDFs vereinfacht. Diese Funktionalität ermöglicht es Benutzern, Berichte, Übersichten und historische Daten der Netzwerküberwachung einfach zu exportieren und zu archivieren.

## Projektstruktur

Das Projekt ist in einer Monorepo-Struktur organisiert, die Frontend- und Backend-Code sowie gemeinsam genutzte Ressourcen in einem einzigen Repository vereint. Dies fördert die Code-Wiederverwendung und vereinfacht die Verwaltung von Abhängigkeiten.

*   `client/`: Dieses Verzeichnis beherbergt den gesamten Frontend-Code der React-Anwendung.
    *   `client/src/`: Der Hauptquellcode des Frontends.
        *   `client/src/components/`: Enthält wiederverwendbare UI-Komponenten (z.B. Buttons, Modals, Navigationsleisten), die an verschiedenen Stellen in der Anwendung eingesetzt werden können. Diese sind oft generisch gehalten und können über Props konfiguriert werden.
        *   `client/src/pages/`: Beinhaltet die Hauptseiten der Anwendung, wie z.B. das Dashboard, die Geräteseite, die Passwortverwaltung oder die Sicherheitsereignisse. Jede Datei in diesem Verzeichnis repräsentiert typischerweise eine Route oder einen Hauptansichtsbereich der Anwendung.
        *   `client/src/lib/`: Hier sind Hilfsfunktionen, Dienstprogramme und Konfigurationen untergebracht, die von mehreren Komponenten oder Seiten benötigt werden. Beispiele hierfür sind die `queryClient.ts` für die Konfiguration von `@tanstack/react-query` und die API-Anfragen, oder andere allgemeine Utility-Funktionen.
        *   `client/src/hooks/`: Enthält benutzerdefinierte React Hooks, die wiederverwendbare Logik kapseln und den Zustand von Komponenten verwalten. Dies fördert die Trennung von Belangen und die Wiederverwendbarkeit von Logik.
*   `server/`: Dieses Verzeichnis enthält den gesamten Backend-Code der Node.js/Express-Anwendung.
    *   `server/api/`: Definiert die REST-API-Endpunkte für verschiedene Ressourcen. Jede Datei in diesem Verzeichnis (z.B. `BandwidthMetrics.ts`, `Geräte-api.ts`) ist für die Handhabung von Anfragen und die Interaktion mit der Datenbank für eine spezifische Datenressource zuständig.
    *   `server/db.ts`: Verwaltet die Datenbankverbindung und initialisiert die Drizzle ORM-Instanz. Hier werden die Datenbankkonfiguration und die Schema-Definitionen für die Interaktion mit PostgreSQL festgelegt.
    *   `server/index.ts`: Die Hauptserverdatei, die die Express-Anwendung initialisiert, Middleware konfiguriert und alle definierten API-Routen registriert. Dies ist der Einstiegspunkt für den Backend-Server.
    *   `server/routes.ts`: Definiert die zentralen Routen für die Express-Anwendung und verknüpft sie mit den entsprechenden API-Handlern aus dem `api/`-Verzeichnis.
    *   `server/storage.ts`: Enthält Logik für die Dateispeicherung oder andere persistente Speicherlösungen, falls die Anwendung solche Funktionen benötigt (z.B. für das Speichern von Konfigurationsdateien oder Exporten).
*   `shared/`: Dieses Verzeichnis ist für Code vorgesehen, der sowohl vom Frontend als auch vom Backend gemeinsam genutzt wird. Dies ist entscheidend für die Typsicherheit und Konsistenz in einer Full-Stack-TypeScript-Anwendung.
    *   `shared/schema.ts`: Enthält gemeinsam genutzte Schemata und Typdefinitionen, die von Drizzle ORM für die Datenbank und von Zod für die Validierung von API-Anfragen und -Antworten verwendet werden. Dies stellt sicher, dass die Datenstrukturen zwischen Client und Server synchronisiert sind.
*   `scripts/`: Beherbergt verschiedene Skripte, die für Entwicklungs- und Wartungsaufgaben verwendet werden.
    *   `scripts/db-test.ts`: Ein Skript zum Einfügen von Mock-Daten in die Datenbank, nützlich für die Entwicklung und das Testen der Anwendung.
    *   `scripts/tables.ts`: Kann Skripte zur Definition oder Initialisierung von Datenbanktabellen enthalten.
*   `drizzle.config.ts`: Die Konfigurationsdatei für Drizzle ORM-Migrationen. Sie definiert, wo die Schema-Definitionen zu finden sind und wie Datenbankmigrationen durchgeführt werden sollen.
*   `.env`: Eine Datei zur Speicherung von Umgebungsvariablen (z.B. `DATABASE_URL`, API-Schlüssel). Diese Datei wird nicht im Versionskontrollsystem gespeichert und ist für sensible Informationen vorgesehen.
*   `package.json`: Definiert die Projektmetadaten und listet alle Abhängigkeiten für das gesamte Monorepo auf, sowohl für das Frontend als auch für das Backend.

## Funktionsweise des Projekts

Das Projekt ist nach einer klassischen Client-Server-Architektur aufgebaut, die eine klare Trennung der Verantwortlichkeiten zwischen Frontend und Backend gewährleistet. Die Kommunikation erfolgt über RESTful-APIs, wobei das Frontend als Konsument und das Backend als Anbieter der Daten fungiert.

*   **Datenfluss und API-Interaktion**: Der gesamte Datenfluss beginnt typischerweise im Frontend, wenn der Benutzer eine Aktion auslöst (z.B. das Laden einer Seite, das Filtern von Daten oder das Speichern von Informationen). Die React-Anwendung sendet entsprechende HTTP-Anfragen (GET, POST, PUT, DELETE) an die definierten REST-API-Endpunkte des Node.js/Express-Servers. Diese Anfragen werden im Backend von den jeweiligen API-Handlern (z.B. in `server/api/BandwidthMetrics.ts`) empfangen und verarbeitet. Nach der Verarbeitung, die oft eine Interaktion mit der Datenbank beinhaltet, sendet der Server die angeforderten Daten oder eine Bestätigung als JSON-Antwort zurück an den Client. `@tanstack/react-query` im Frontend verwaltet diesen Prozess effizient, indem es Anfragen optimiert, Caching implementiert und den Zustand der Daten synchronisiert.

*   **Datenbankinteraktion mit Drizzle ORM**: Das Herzstück der Datenhaltung ist die PostgreSQL-Datenbank. Der Node.js/Express-Server interagiert ausschließlich über Drizzle ORM mit der Datenbank. Drizzle ORM übersetzt die typsicheren TypeScript-Abfragen des Backends in optimierte SQL-Statements. Dies gewährleistet nicht nur die Datenintegrität und -konsistenz, sondern auch eine hohe Performance bei Datenbankoperationen. Alle relevanten Informationen – von den Konfigurationsdaten der Netzwerkgeräte über detaillierte Bandbreitenmetriken und historische Sicherheitsereignisse bis hin zu Benutzerprofilen und verschlüsselten Passwort-Tresoren – werden hier persistent gespeichert. Schema-Definitionen in `shared/schema.ts` stellen sicher, dass die Datenstrukturen zwischen Frontend und Backend konsistent sind.

*   **Benutzeroberfläche und Datenvisualisierung**: Das React-Frontend ist für die Darstellung der Daten und die Interaktion mit dem Benutzer verantwortlich. Es nutzt eine komponentengesteuerte Architektur, bei der jede UI-Komponente (z.B. ein Diagramm, eine Tabelle, ein Formular) einen spezifischen Teil der Benutzeroberfläche darstellt. Daten, die vom Backend empfangen werden, werden von diesen Komponenten verarbeitet und visualisiert. Insbesondere `Chart.js` wird eingesetzt, um komplexe Metriken wie Bandbreitennutzung und Systemauslastung in leicht verständlichen und interaktiven Diagrammen darzustellen. Die Kombination aus React, Tailwind CSS und Shadcn/ui ermöglicht eine moderne, responsive und benutzerfreundliche Oberfläche.

*   **Echtzeit-Updates und Datenaktualisierung**: Um eine nahezu Echtzeit-Ansicht der Netzwerkdaten zu gewährleisten, nutzt das Frontend die `refetchIntervals`-Funktion von `@tanstack/react-query`. Dies bedeutet, dass bestimmte Daten (z.B. aktuelle Bandbreitennutzung oder Gerätestatus) in regelmäßigen, konfigurierbaren Intervallen automatisch vom Server abgerufen werden. Sobald neue Daten verfügbar sind, aktualisiert React die betroffenen UI-Komponenten effizient, ohne dass die gesamte Seite neu geladen werden muss. Dies sorgt für eine dynamische und stets aktuelle Darstellung der Netzwerkumgebung.

